<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linux Terminal Simulator</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
      background-color: #000;
      color: #0f0;
    }
    #terminal {
      padding: 1rem;
      white-space: pre-wrap;
      height: 100vh;
      overflow-y: auto;
    }
    .input-line {
      display: flex;
    }
    .prompt {
      margin-right: 0.5rem;
    }
    input {
      background: none;
      border: none;
      outline: none;
      flex: 1;
      font-family: monospace;
      font-size: 1rem;
      color: #0f0;
    }
    .modal {
      position: fixed;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 70%;
      background: #111;
      border: 2px solid #0f0;
      z-index: 10;
      padding: 1rem;
      display: flex;
      flex-direction: column;
    }
    .modal textarea {
      flex: 1;
      background: #000;
      color: #0f0;
      border: none;
      resize: none;
      font-family: monospace;
    }
    .modal button {
      margin-top: 1rem;
      padding: 0.5rem;
      background: #0f0;
      color: #000;
      font-weight: bold;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="terminal"></div>
  <script>
    const terminal = document.getElementById("terminal");
    const MAX_FILE_SIZE = 5 * 1024 * 1024;
    let currentPath = ["/"];
    let fileSystem = {
      type: "dir",
      name: "/",
      children: []
    };

    const defaultTextColor = "#0f0";
    const colorMap = {
      green: "#0f0",
      red: "#f00",
      yellow: "#ff0",
      blue: "#00f",
      white: "#fff",
      cyan: "#0ff",
      magenta: "#f0f"
    };

    function getCurrentDir() {
      let dir = fileSystem;
      for (let i = 1; i < currentPath.length; i++) {
        dir = dir.children.find(c => c.name === currentPath[i] && c.type === "dir");
        if (!dir) return null;
      }
      return dir;
    }

    function renderPrompt() {
      const line = document.createElement("div");
      line.className = "input-line";

      const prompt = document.createElement("span");
      prompt.className = "prompt";
      prompt.textContent = `user@fakeOS:${currentPath.join("/")}$`;
      prompt.style.color = document.body.style.color;

      const input = document.createElement("input");
      input.style.color = document.body.style.color;
      input.autofocus = true;
      input.addEventListener("keydown", handleCommand);

      line.appendChild(prompt);
      line.appendChild(input);
      terminal.appendChild(line);

      // Donne le focus sur l'input chaque fois que le prompt est affiché
      input.focus();
      terminal.scrollTop = terminal.scrollHeight;
    }

    function handleCommand(e) {
      if (e.key === "Enter") {
        const input = e.target;
        const commandText = input.value.trim();
        if (commandText === "") return;  // Empêche d'exécuter une commande vide

        const output = document.createElement("div");
        output.textContent = `\n$ ${commandText}`;
        terminal.appendChild(output);

        executeCommand(commandText);

        input.disabled = true; // Désactive le champ d'entrée une fois la commande exécutée
        renderPrompt(); // Affiche un nouveau prompt
      }
    }

    function findEntry(name, type) {
      const dir = getCurrentDir();
      return dir.children.find(c => c.name === name && (!type || c.type === type));
    }

    function simulateCommand(name, defaultOutput) {
      terminal.append("\n" + (defaultOutput || `${name}: not implemented in this simulation.`));
    }

    function executeCommand(cmd) {
      const [command, ...args] = cmd.split(" ");
      const currentDir = getCurrentDir();
      if (!currentDir) return;

      switch (command) {
        case "ls": {
          const items = currentDir.children.map(c => c.name).join("  ");
          terminal.append(`\n${items}`);
          break;
        }
        case "pwd": {
          terminal.append(`\n${currentPath.join("/")}`);
          break;
        }
        case "cd": {
          const target = args[0];
          if (!target || target === "/") {
            currentPath = ["/"];
          } else if (target === "..") {
            if (currentPath.length > 1) currentPath.pop();
          } else {
            const dir = currentDir.children.find(c => c.name === target && c.type === "dir");
            if (dir) currentPath.push(target);
            else terminal.append("\nNo such directory.");
          }
          break;
        }
        case "mkdir": {
          const name = args[0];
          if (!name) break;
          if (findEntry(name)) {
            terminal.append("\nDirectory already exists.");
          } else {
            currentDir.children.push({ type: "dir", name, children: [] });
          }
          break;
        }
        case "touch": {
          const name = args[0];
          if (!name || !name.endsWith(".txt")) {
            terminal.append("\nOnly .txt files are supported.");
            break;
          }
          if (findEntry(name)) {
            terminal.append("\nFile already exists.");
          } else {
            currentDir.children.push({ type: "file", name, content: "", size: 0 });
          }
          break;
        }
        case "cat": {
          const name = args[0];
          const file = findEntry(name, "file");
          if (file) terminal.append(`\n${file.content}`);
          else terminal.append("\nFile not found.");
          break;
        }
        case "nano": {
          const name = args[0];
          const file = findEntry(name, "file");
          if (!file) {
            terminal.append("\nFile not found.");
            return;
          }
          const modal = document.createElement("div");
          modal.className = "modal";

          const textarea = document.createElement("textarea");
          textarea.value = file.content;

          const saveButton = document.createElement("button");
          saveButton.textContent = "Save";
          saveButton.onclick = () => {
            const newSize = new Blob([textarea.value]).size;
            if (newSize <= MAX_FILE_SIZE) {
              file.content = textarea.value;
              file.size = newSize;
              modal.remove();
            } else {
              alert("File exceeds 5MB limit.");
            }
          };

          modal.appendChild(textarea);
          modal.appendChild(saveButton);
          document.body.appendChild(modal);
          break;
        }
        case "echo": {
          const match = cmd.match(/echo\s+(.+)\s+>>\s+(.+)/);
          if (match) {
            const text = match[1];
            const fileName = match[2];
            const file = findEntry(fileName, "file");
            if (file) {
              const newSize = new Blob([file.content + text]).size;
              if (newSize <= MAX_FILE_SIZE) {
                file.content += text;
                file.size = newSize;
              } else {
                terminal.append("\nFile exceeds 5MB limit.");
              }
            } else {
              terminal.append("\nTarget file not found.");
            }
          } else {
            terminal.append("\nInvalid echo syntax. Use: echo [text] >> [file.txt]");
          }
          break;
        }
        case "rm": {
          const name = args[0];
          const index = currentDir.children.findIndex(c => c.name === name && c.type === "file");
          if (index !== -1) {
            currentDir.children.splice(index, 1);
          } else {
            terminal.append("\nFile not found.");
          }
          break;
        }
        case "rmdir": {
          const name = args[0];
          const index = currentDir.children.findIndex(c => c.name === name && c.type === "dir");
          if (index !== -1) {
            if (currentDir.children[index].children.length === 0) {
              currentDir.children.splice(index, 1);
            } else {
              terminal.append("\nDirectory not empty.");
            }
          } else {
            terminal.append("\nDirectory not found.");
          }
          break;
        }
        case "tree": {
          function buildTree(dir, prefix = "") {
            let result = `${prefix}${dir.name}/\n`;
            for (let child of dir.children) {
              if (child.type === "dir") {
                result += buildTree(child, prefix + "  ");
              } else {
                result += `${prefix}  ${child.name}\n`;
              }
            }
            return result;
          }
          terminal.append("\n" + buildTree(getCurrentDir()));
          break;
        }
        case "color": {
          const color = args[0]?.toLowerCase();
          if (colorMap[color]) {
            document.body.style.color = colorMap[color];
            terminal.append(`\nText color set to ${color}`);
          } else {
            terminal.append("\nInvalid color. Available: " + Object.keys(colorMap).join(", "));
          }
          break;
        }
        case "clear": {
          terminal.innerHTML = "";
          break;
        }
        case "help": {
          terminal.append("\nCommands: ls, pwd, cd, mkdir, rmdir, touch, cat, nano, echo >> file.txt, rm, tree, color, clear, help");
          break;
        }
        case "mv":
        case "cp":
        case "ln":
        case "less":
        case "man":
        case "uname": {
          simulateCommand(command, "Linux fakeOS 1.0.0 x86_64");
          break;
        }
        case "whoami": {
          simulateCommand(command, "user");
          break;
        }
        default:
          terminal.append("\nCommand not found.");
      }
    }

    terminal.append("Welcome to the Linux Terminal Simulator! Type 'help' for a list of commands.\n");
    renderPrompt();
  </script>
</body>
</html>
